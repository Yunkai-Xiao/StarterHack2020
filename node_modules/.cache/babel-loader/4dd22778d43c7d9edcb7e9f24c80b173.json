{"ast":null,"code":"import utils from './utils';\nimport getOffsetParent from './getOffsetParent';\nimport isAncestorFixed from './isAncestorFixed';\n/**\n * 获得元素的显示部分的区域\n */\n\nfunction getVisibleRectForElement(element) {\n  var visibleRect = {\n    left: 0,\n    right: Infinity,\n    top: 0,\n    bottom: Infinity\n  };\n  var el = getOffsetParent(element);\n  var doc = utils.getDocument(element);\n  var win = doc.defaultView || doc.parentWindow;\n  var body = doc.body;\n  var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for\n  // all scrollable containers.\n\n  while (el) {\n    // clientWidth is zero for inline block elements in ie.\n    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire\n    // viewport. In some browsers, el.offsetParent may be\n    // document.documentElement, so check for that too.\n    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {\n      var pos = utils.offset(el); // add border\n\n      pos.left += el.clientLeft;\n      pos.top += el.clientTop;\n      visibleRect.top = Math.max(visibleRect.top, pos.top);\n      visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar\n      pos.left + el.clientWidth);\n      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);\n      visibleRect.left = Math.max(visibleRect.left, pos.left);\n    } else if (el === body || el === documentElement) {\n      break;\n    }\n\n    el = getOffsetParent(el);\n  } // Set element position to fixed\n  // make sure absolute element itself don't affect it's visible area\n  // https://github.com/ant-design/ant-design/issues/7601\n\n\n  var originalPosition = null;\n\n  if (!utils.isWindow(element) && element.nodeType !== 9) {\n    originalPosition = element.style.position;\n    var position = utils.css(element, 'position');\n\n    if (position === 'absolute') {\n      element.style.position = 'fixed';\n    }\n  }\n\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  var documentWidth = documentElement.scrollWidth;\n  var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.\n  // We should cut this ourself.\n\n  var bodyStyle = window.getComputedStyle(body);\n\n  if (bodyStyle.overflowX === 'hidden') {\n    documentWidth = win.innerWidth;\n  }\n\n  if (bodyStyle.overflowY === 'hidden') {\n    documentHeight = win.innerHeight;\n  } // Reset element position after calculate the visible area\n\n\n  if (element.style) {\n    element.style.position = originalPosition;\n  }\n\n  if (isAncestorFixed(element)) {\n    // Clip by viewport's size.\n    visibleRect.left = Math.max(visibleRect.left, scrollX);\n    visibleRect.top = Math.max(visibleRect.top, scrollY);\n    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);\n    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);\n  } else {\n    // Clip by document's size.\n    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);\n    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);\n    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);\n    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);\n  }\n\n  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;\n}\n\nexport default getVisibleRectForElement;","map":{"version":3,"sources":["/Users/SHAWN/Downloads/StudyMate2/node_modules/dom-align/es/getVisibleRectForElement.js"],"names":["utils","getOffsetParent","isAncestorFixed","getVisibleRectForElement","element","visibleRect","left","right","Infinity","top","bottom","el","doc","getDocument","win","defaultView","parentWindow","body","documentElement","navigator","userAgent","indexOf","clientWidth","css","pos","offset","clientLeft","clientTop","Math","max","min","clientHeight","originalPosition","isWindow","nodeType","style","position","scrollX","getWindowScrollLeft","scrollY","getWindowScrollTop","viewportWidth","viewportHeight","documentWidth","scrollWidth","documentHeight","scrollHeight","bodyStyle","window","getComputedStyle","overflowX","innerWidth","overflowY","innerHeight","maxVisibleWidth","maxVisibleHeight"],"mappings":"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","sourcesContent":["import utils from './utils';\nimport getOffsetParent from './getOffsetParent';\nimport isAncestorFixed from './isAncestorFixed';\n\n/**\n * 获得元素的显示部分的区域\n */\nfunction getVisibleRectForElement(element) {\n  var visibleRect = {\n    left: 0,\n    right: Infinity,\n    top: 0,\n    bottom: Infinity\n  };\n  var el = getOffsetParent(element);\n  var doc = utils.getDocument(element);\n  var win = doc.defaultView || doc.parentWindow;\n  var body = doc.body;\n  var documentElement = doc.documentElement;\n\n  // Determine the size of the visible rect by climbing the dom accounting for\n  // all scrollable containers.\n  while (el) {\n    // clientWidth is zero for inline block elements in ie.\n    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&\n    // body may have overflow set on it, yet we still get the entire\n    // viewport. In some browsers, el.offsetParent may be\n    // document.documentElement, so check for that too.\n    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {\n      var pos = utils.offset(el);\n      // add border\n      pos.left += el.clientLeft;\n      pos.top += el.clientTop;\n      visibleRect.top = Math.max(visibleRect.top, pos.top);\n      visibleRect.right = Math.min(visibleRect.right,\n      // consider area without scrollBar\n      pos.left + el.clientWidth);\n      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);\n      visibleRect.left = Math.max(visibleRect.left, pos.left);\n    } else if (el === body || el === documentElement) {\n      break;\n    }\n    el = getOffsetParent(el);\n  }\n\n  // Set element position to fixed\n  // make sure absolute element itself don't affect it's visible area\n  // https://github.com/ant-design/ant-design/issues/7601\n  var originalPosition = null;\n  if (!utils.isWindow(element) && element.nodeType !== 9) {\n    originalPosition = element.style.position;\n    var position = utils.css(element, 'position');\n    if (position === 'absolute') {\n      element.style.position = 'fixed';\n    }\n  }\n\n  var scrollX = utils.getWindowScrollLeft(win);\n  var scrollY = utils.getWindowScrollTop(win);\n  var viewportWidth = utils.viewportWidth(win);\n  var viewportHeight = utils.viewportHeight(win);\n  var documentWidth = documentElement.scrollWidth;\n  var documentHeight = documentElement.scrollHeight;\n\n  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.\n  // We should cut this ourself.\n  var bodyStyle = window.getComputedStyle(body);\n  if (bodyStyle.overflowX === 'hidden') {\n    documentWidth = win.innerWidth;\n  }\n  if (bodyStyle.overflowY === 'hidden') {\n    documentHeight = win.innerHeight;\n  }\n\n  // Reset element position after calculate the visible area\n  if (element.style) {\n    element.style.position = originalPosition;\n  }\n\n  if (isAncestorFixed(element)) {\n    // Clip by viewport's size.\n    visibleRect.left = Math.max(visibleRect.left, scrollX);\n    visibleRect.top = Math.max(visibleRect.top, scrollY);\n    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);\n    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);\n  } else {\n    // Clip by document's size.\n    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);\n    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);\n\n    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);\n    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);\n  }\n\n  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;\n}\n\nexport default getVisibleRectForElement;"]},"metadata":{},"sourceType":"module"}